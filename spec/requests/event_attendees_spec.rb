# frozen_string_literal: true

require "rails_helper"

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe "/event_attendees" do
  let(:event_attendee) { create :event_attendee }

  let(:user) { nil }

  before(:each) do
    sign_in user if user
  end

  describe "GET /index" do
    subject(:get_index) { get event_attendees_url, params: }

    let(:params) { { format: :json } }

    context "when user is logged in" do
      let!(:event_attendee) { create_list :event_attendee, 2, organizer: true }
      let(:user) { event_attendee[0].profile.user }

      context "without event_id parameter" do
        it "renders a successful response" do
          get_index
          expect(json_body["event_attendees"].pluck("profile_id")).to include(event_attendee[0].profile_id)
        end

        it "don't render other users records" do
          get_index
          expect(json_body["event_attendees"].pluck("profile_id")).not_to include(event_attendee[1].profile_id)
        end

        it "includes pagination links" do
          get_index
          expect(json_body).to have_key("links")
        end
      end

      context "with event_id parameter" do
        let!(:event) { create :event }
        let!(:event_attendee_list) { create_list :event_attendee, 3, event: }
        let(:params) { { format: :json, event_id: event.id } }

        before do
          # Make all profiles visible to everyone for this test
          event_attendee_list.each { |ea| ea.profile.update!(visibility: 'everyone') }
        end

        it "returns attendees for the specified event" do
          get_index
          expect(json_body["event_attendees"].length).to eq(3)
          expect(json_body["event_attendees"].pluck("event_id")).to all(eq(event.id))
        end

        it "includes pagination links" do
          get_index
          expect(json_body).to have_key("links")
        end

        context "with pagination" do
          let!(:many_attendees) { create_list :event_attendee, 15, event: }
          let(:params) { { format: :json, event_id: event.id, page: { number: 2 } } }

          before do
            many_attendees.each { |ea| ea.profile.update!(visibility: 'everyone') }
          end

          it "paginates the results" do
            get_index
            expect(json_body["event_attendees"].count).to be <= 10
            expect(json_body["links"]).to have_key("prev")
          end
        end

        context "with different profile visibilities" do
          let!(:public_attendee) { create :event_attendee, event:, profile: create(:profile, visibility: 'everyone') }
          let!(:private_attendee) { create :event_attendee, event:, profile: create(:profile, visibility: 'myself') }
          let!(:friends_attendee) { create :event_attendee, event:, profile: create(:profile, visibility: 'friends') }
          let!(:authenticated_attendee) { create :event_attendee, event:, profile: create(:profile, visibility: 'authenticated') }

          it "respects profile visibility settings" do
            get_index
            returned_profile_ids = json_body["event_attendees"].pluck("profile_id")
            
            # Should include public and authenticated profiles
            expect(returned_profile_ids).to include(public_attendee.profile_id)
            expect(returned_profile_ids).to include(authenticated_attendee.profile_id)
            
            # Should not include private profiles
            expect(returned_profile_ids).not_to include(private_attendee.profile_id)
            
            # Should not include friends-only profiles (since we're not friends)
            expect(returned_profile_ids).not_to include(friends_attendee.profile_id)
          end
        end
      end
    end
  end

  describe "GET /show" do
    subject(:get_show) { get event_attendee_url(event_attendee) }

    include_examples "unauthorized access"

    context "with your event attendee" do
      let(:user) { create :user }
      let(:profile) { create :profile, user: }
      let(:event_attendee) { create :event_attendee, profile: }

      it "renders a successful response" do
        get_show
        expect(response).to be_successful
      end
    end
  end

  describe "GET /new" do
    subject(:get_new) { get new_event_attendee_url }

    include_examples "redirect to sign in"

    context "when user is logged in" do
      let(:user) { create :user }

      it "renders a successful response" do
        get_new
        expect(response).to be_successful
      end
    end
  end

  describe "GET /edit" do
    subject(:get_edit) { get edit_event_attendee_url(event_attendee) }

    include_examples "redirect to sign in"
  end

  describe "POST /create" do
    subject(:post_create) { post event_attendees_url, params: { event_attendee: attributes } }

    context "with valid parameters" do
      let(:profile) { create :profile }
      let(:event) { create :event }
      let(:attributes) do
        {
          profile_id: profile.id,
          event_id: event.id
        }
      end

      include_examples "redirect to sign in"

      context "when user does not match profile" do
        let(:user) { create :user }

        include_examples "unauthorized access"
      end

      context "when user matches profile" do
        let(:user) { profile.user }

        it "creates a new EventAttendee" do
          expect { post_create }.to change(EventAttendee, :count).by(1)
        end

        it "schedules an email" do
          post_create
          event_attendee = EventAttendee.find_by(event:, profile:)
          expect(event_attendee.email_scheduled_on).not_to be_nil
        end

        it "redirects to the created event_attendee" do
          post_create
          expect(response).to redirect_to(event_attendee_url(EventAttendee.last))
        end
      end

      context "when user matches profile but is overdue on email confirmation" do
        let(:user) { create :user, :overdue_unconfirmed }
        let(:profile) { create :profile, user: }

        it_behaves_like "confirm your email"
      end

      context "when user matches profile and is unconfirmed" do
        let(:user) { create :user, :unconfirmed_with_trial }
        let(:profile) { create :profile, user: }

        it "creates a new EventAttendee" do
          expect { post_create }.to change(EventAttendee, :count).by(1)
        end

        it "redirects to the created event_attendee" do
          post_create
          expect(response).to redirect_to(event_attendee_url(EventAttendee.last))
        end
      end
    end

    context "with invalid parameters and valid user" do
      let(:attributes) { { profile_id: profile.id } }
      let(:profile) { create :profile }
      let(:user) { profile.user }

      it "does not create a new EventAttendee" do
        expect { post_create }.not_to change(EventAttendee, :count)
      end

      it "returns an unprocessable entity code" do
        post_create
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end

  describe "PATCH /update" do
    subject(:patch_update) { patch event_attendee_url(event_attendee), params: { event_attendee: attributes } }

    let(:event_attendee) { create :event_attendee }

    context "with valid parameters" do
      let(:attributes) do
        { event_id: create(:event, name: "StrangeLoop").id }
      end

      include_examples "redirect to sign in"

      context "when user does not match profile" do
        let(:user) { create :user }

        include_examples "unauthorized access"
      end
    end
  end

  describe "DELETE /destroy" do
    subject(:delete_destroy) { delete event_attendee_url(event_attendee) }

    let!(:event_attendee) { create :event_attendee }

    include_examples "redirect to sign in"

    context "when unrelated user" do
      let(:user) { create :user }

      include_examples "unauthorized access"

      it "does not allow folks to delete others event attendance" do
        delete_destroy
        expect(event_attendee.id).to eq event_attendee.reload.id
      end
    end

    context "when user matches profile" do
      let(:user) { event_attendee.profile.user }

      it "destroys the requested event_attendee" do
        expect { delete_destroy }.to change(EventAttendee, :count).by(-1)
      end

      it "redirects to the event_attendees list" do
        delete_destroy
        expect(response).to redirect_to(event_attendees_url)
      end
    end
  end
end
